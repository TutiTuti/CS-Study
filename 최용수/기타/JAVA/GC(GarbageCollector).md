## GC ( Garbage Collector ) 란?
- 힙 영역에서 사용하지 않은 객체들을 제거하는 작업이다.
- 이 객체를 제거하는 작업이 필요한 이유는 자바는 개발자가 메모리를 직접 해제할 수 없는 언어이기 때문이며 객체를 사용하고 제거하는 기능이 반드시 필요하다.
- JVM의 Heap 영역에서 동적으로 할당됐던 메모리 영역 중에 필요 없어진 메모리 영역을 주기적으로 제거한다.

### GC의 단점
- 개발자가 메모리가 언제 해제되는지를 정확하게 알 수 없다.
- GC가 동작하는 동안에 다른 동작이나 JVM을 멈추기 때문에 성능상 오버헤드가 발생한다.     
오버헤드 : 프로그램의 실행 도중 동떨어진 위치의 코드를 실행시켜야 할 때 추가적으로 시간,메모리,자원이 사용되는 현상      

### Heap 영역
![img1 daumcdn](https://github.com/kj-cs-study/CS-Study/assets/37789623/5bca23fe-0623-4203-9ef5-bd4297ff8285)

- Heap 역역은 효울적인 GC를 위해 위와 같이 3가지 영역으로 나뉜다.
- YoungGeneration : 자바 객체가 생성되자마자 저장되고 생긴지 얼마 안된 객체들이 저장되는 공간이다. Heap 영역에 객체가 생성되면 최초로 Eden 영역에 할당되며
이 영역에서 어느정도 데이터가 쌓이게 되면 참조되는 정도에 따라 Servivor의 빈공간으로 이동되건 회수가 이루어진다.
- YoungGeneration 영역이 차면 또 참조 정도에 따라 Old영역으로 이동되거나 회수가 이루어진다. 이렇게 YoungGeneration과 TenuredGeneration 에서의 GC를 Minor GC라고 하며
Old영역에 할당된 메모리가 허용치를 넘어 가면 Old 역역의 있는 모든 객체들을 검사해 참조되지 않은 객체를 한꺼번에 삭제하는 GC가 동작된다.
이때 시간이 오래 걸리는 작업이므로 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들은 작업을 멈추게 된다.
- 이것을 'Stop-the-World'라고 하며 멈추게 되면 Old 영역의 메모리 회수하는 GC를 Major GC라고 한다.

### Heap 영역 GC
- Minor GC는 young영역 , Major GC는 Old 영역에서 일어난다
- Minor GC는 Eden 영역이 가득차면 시작되며, Eden영역에서 참조가 남아있는 객체를 Mark하고 Survivor영역으로 복사한다. 그리고 Eden영역을 비운다.
Survivor 영역도 가득차면 같은방식으로 다른 Survivor영역으로 복사하고 비우며 반복하다 보면 계속 살아남는 객체들은 Old영역으로 이동한다.
- Major GC는 Old 영역에서 일어나며 위와 반대로 삭제되어야 하는 객체를 Mark한다. 그리고 지우는(Sweep)작업을 진행한다.
메모리는 단편화된 상태이므로 이를 한 군데로 모아주는 것을 Compaction이라고 하며 compact라고도 부른다. 그래서 Mark-Sweep-Compact알고리즘을 수행한다.

#### Mark-Sweep-compact 알고리즘
- Mark-Sweep-Compact 알고리즘은 GC가 동작하는 원리로 루트에서부터 해당 객체를 접근 가능한지에 대한 여부의 기준으로 메모리를 해제한다.
> - Mark 과정 : 먼저 Root로 부터 그랲 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지를 찾으며 마킹을 한다.
> - Sweep 과정 : 참조하고 있지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거한다.
> - Compact 과정 : Sweep 후에 분산된 객체들을 Heap의 시작주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축한다.
  그러나 가비지 컬렉션의 종류에 따라 하지 않을수도 있다.
  
#### 이런 GC의 동작들이 중요한 이유는 GC 을 수행하면 시스템이 멈추기 떄문에 의도치 않은 장애의 원인이 될 수 있으며 따라서 이를 위해 힙영역을 조정하는 것을 GC 튜닝이라고 하며 JVM 메모리는 절대로 마음대로 조정해서 안된다.
