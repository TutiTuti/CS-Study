## CSRF

> 웹 보안 취약점의 일종이며, 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(데이터 수정, 삭제, 등록 등) 을 특정 웹사이트에 요청하게 하는 공격
> 

### CSRF 전제조건

1️⃣ 사용자는 보안이 취약한 서버로부터 이미 로그인되어 있는 상태여야 합니다.

2️⃣ 쿠키 기반의 서버 세션 정보를 획득할 수 있어야 합니다.

3️⃣ 공격자는 서버를 공격하기 위한 요청 방법에 대해 미리 파악하고 있어야 합니다.

### CSRF 과정

1️⃣ 사용자는 보안이 취약한 서버에 로그인합니다.

2️⃣ 로그인 이후 서버에 저장된 세션 정보를 사용할 수 있는 `sessionID`가 사용자 브라우저 쿠키에 저장됩니다.

3️⃣ 공격자는 서버에 인증된 브라우저의 사용자가 악성 스크립트 페이지를 누르도록 유도합니다.

- 해당 악성 스크립트가 담긴 페이지를 클릭하도록 유도하는 방법은 다양한 것 같으나 몇 가지 유형을 정리하자면 다음과 같습니다.
- 게시판에 악성 스크립트를 게시글로 작성하여 관리자 혹은 다른 사용자들이 게시글을 클릭하도록 유도합니다.
- 메일 등으로 악성 스크립트를 직접 전달하거나, 악성 스크립트가 적힌 페이지 링크를 전달합니다.

4️⃣ 사용자가 악성 스크립트가 작성된 페이지 접근시 쿠키에 저장된 `sessionID`는 브라우저에 의해 자동적으로 함께 서버로 요청됩니다.

5️⃣ 서버는 쿠키에 담긴 `sessionID`를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리합니다.

### 방어 방법

**1️⃣ Referrer 검증**

서버에서 사용자의 요청에 `Referrer` 정보를 확인하는 방법이 있습니다. 요청 헤더(request header) 정보에서 `Referrer` 정보를 확인할 수 있습니다. 보통이라면 호스트(host)와 `Referrer` 값이 일치하므로 둘을 비교합니다. CSRF 공격의 대부분 `Referrer` 값에 대한 검증만으로 방어가 가능하다고 합니다

**2️⃣ CSRF 토큰 검증**

임의의 CSRF 토큰을 만들어 세션에 저장합니다. 요청하는 페이지에 `hidden` 타입 input 태그를 이용해 토큰 값을 함께 전달합니다. 이후 서버에서 세션에 저장된 CSRF 토큰 값과 요청 파라미터에 담긴 토큰 값을 비교합니다.

**3️⃣ Double Submit Cookie 검증**

브라우저의 `Same Origin 정책`을 이용합니다. `Same Origin`이 아닌 경우 `JavaScript`로 쿠키 값을 확인하거나 수정하지 못한다는 점을 이용한 검증 방법입니다. 클라이언트(브라우저)에서 `JavaScript`로 임의의 생성한 토큰을 쿠키와 요청 헤더에 각각 담아서 서버에게 전달합니다. 서버는 전달받은 쿠키와 요청 헤더에서 각자 토큰 값을 꺼내어 이를 비교합니다. 이때, 쿠키에 저장된 토큰 정보는 이후에 재사용하지 못하도록 만료 처리합니다.

### 참고

[https://junhyunny.github.io/information/security/spring-boot/spring-security/cross-site-reqeust-forgery/](https://junhyunny.github.io/information/security/spring-boot/spring-security/cross-site-reqeust-forgery/)
